using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using CSnakes.Parser;
using CSnakes.Parser.Types;
using CSnakes.Reflection;
using System.Collections.Immutable;

namespace CSnakes;

[Generator(LanguageNames.CSharp)]
public class PythonStaticGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // System.Diagnostics.Debugger.Launch();
        var pythonFilesPipeline = context.AdditionalTextsProvider
            .Where(static text => Path.GetExtension(text.Path) == ".py")
            .Collect();

        context.RegisterSourceOutput(pythonFilesPipeline, static (sourceContext, inputFiles) =>
        {
            foreach (var file in inputFiles)
            {
                // Add environment path
                var @namespace = "CSnakes.Runtime";

                var fileName = Path.GetFileNameWithoutExtension(file.Path);

                // Convert snakecase to pascal case
                var pascalFileName = string.Join("", fileName.Split('_').Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1)));
                // Read the file
                var code = file.GetText(sourceContext.CancellationToken);

                if (code is null) continue;

                // Parse the Python file
                var result = PythonParser.TryParseFunctionDefinitions(code, out PythonFunctionDefinition[] functions, out GeneratorError[]? errors);

                foreach (var error in errors)
                {
                    // Update text span
                    Location errorLocation = Location.Create(file.Path, TextSpan.FromBounds(0, 1), new LinePositionSpan(new LinePosition(error.StartLine, error.StartColumn), new LinePosition(error.EndLine, error.EndColumn)));
                    sourceContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("PSG004", "PythonStaticGenerator", error.Message, "PythonStaticGenerator", DiagnosticSeverity.Error, true), errorLocation));
                }

                if (result)
                {
                    IEnumerable<MethodDefinition> methods = ModuleReflection.MethodsFromFunctionDefinitions(functions, fileName);
                    string source = FormatClassFromMethods(@namespace, pascalFileName, methods, fileName, functions);
                    sourceContext.AddSource($"{pascalFileName}.py.cs", source);
                    sourceContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("PSG002", "PythonStaticGenerator", $"Generated {pascalFileName}.py.cs", "PythonStaticGenerator", DiagnosticSeverity.Info, true), Location.None));
                }
            }
        });
    }

    public static string FormatClassFromMethods(string @namespace, string pascalFileName, IEnumerable<MethodDefinition> methods, string fileName, PythonFunctionDefinition[] functions)
    {
        var paramGenericArgs = methods
            .Select(m => m.ParameterGenericArgs)
            .Where(l => l is not null && l.Any());

        var functionNames = functions.Select(f => (Attr: f.Name, Field: $"__func_{f.Name}")).ToImmutableArray();

        return $$"""
            // <auto-generated/>
            #nullable enable
            using CSnakes.Runtime;
            using CSnakes.Runtime.Python;

            using System;
            using System.Collections.Generic;
            using System.Diagnostics;

            using Microsoft.Extensions.Logging;

            namespace {{@namespace}};
            public static class {{pascalFileName}}Extensions
            {
                private static I{{pascalFileName}}? instance;

                public static I{{pascalFileName}} {{pascalFileName}}(this IPythonEnvironment env)
                {
                    if (instance is null)
                    {
                        instance = new {{pascalFileName}}Internal(env.Logger);
                    }
                    Debug.Assert(!env.IsDisposed());
                    return instance;
                }

                private class {{pascalFileName}}Internal : I{{pascalFileName}}
                {
                    private readonly PyObject module;

                    private readonly ILogger<IPythonEnvironment> logger;
                    {{string.Join(Environment.NewLine, functionNames.Select(f => $"private readonly PyObject {f.Field};")) }}

                    internal {{pascalFileName}}Internal(ILogger<IPythonEnvironment> logger)
                    {
                        this.logger = logger;
                        using (GIL.Acquire())
                        {
                            logger.LogDebug("Importing module {ModuleName}", "{{fileName}}");
                            module = Import.ImportModule("{{fileName}}");
                            {{ string.Join(Environment.NewLine, functionNames.Select(f => $"this.{f.Field} = module.GetAttr(\"{f.Attr}\");")) }}
                        }
                    }

                    public void Dispose()
                    {
                        logger.LogDebug("Disposing module {ModuleName}", "{{fileName}}");
                        {{ string.Join(Environment.NewLine, functionNames.Select(f => $"this.{f.Field}.Dispose();")) }}
                        module.Dispose();
                    }

                    {{methods.Select(m => m.Syntax).Compile()}}
                }
            }
            public interface I{{pascalFileName}}
            {
                {{string.Join(Environment.NewLine, methods.Select(m => m.Syntax).Select(m => $"{m.ReturnType.NormalizeWhitespace()} {m.Identifier.Text}{m.ParameterList.NormalizeWhitespace()};"))}}
            }
            """;
    }
}