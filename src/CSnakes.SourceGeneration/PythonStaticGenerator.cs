using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using CSnakes.Parser;
using CSnakes.Parser.Types;
using CSnakes.Reflection;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.CSharp;

namespace CSnakes;

[Generator(LanguageNames.CSharp)]
public class PythonStaticGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // System.Diagnostics.Debugger.Launch();
        var pythonFilesPipeline = context.AdditionalTextsProvider
            .Where(static text => Path.GetExtension(text.Path) == ".py");

        context.RegisterSourceOutput(pythonFilesPipeline, static (sourceContext, file) =>
        {
            // Add environment path
            var @namespace = "CSnakes.Runtime";

            var fileName = Path.GetFileNameWithoutExtension(file.Path);

            // Convert snake_case to PascalCase
            var pascalFileName = string.Join("", fileName.Split('_').Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1)));
            // Read the file
            var code = file.GetText(sourceContext.CancellationToken);

            if (code is null) return;

            // Calculate hash of code
            var hash = code.GetContentHash();

            // Parse the Python file
            var result = PythonParser.TryParseFunctionDefinitions(code, out PythonFunctionDefinition[] functions, out GeneratorError[]? errors);

            foreach (var error in errors)
            {
                // Update text span
                Location errorLocation = Location.Create(file.Path, TextSpan.FromBounds(0, 1), new LinePositionSpan(new LinePosition(error.StartLine, error.StartColumn), new LinePosition(error.EndLine, error.EndColumn)));
                sourceContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("PSG004", "PythonStaticGenerator", error.Message, "PythonStaticGenerator", DiagnosticSeverity.Error, true), errorLocation));
            }

            if (result)
            {
                IEnumerable<MethodDefinition> methods = ModuleReflection.MethodsFromFunctionDefinitions(functions, fileName);
                string source = FormatClassFromMethods(@namespace, pascalFileName, methods, fileName, functions, hash);
                sourceContext.AddSource($"{pascalFileName}.py.cs", source);
                sourceContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("PSG002", "PythonStaticGenerator", $"Generated {pascalFileName}.py.cs", "PythonStaticGenerator", DiagnosticSeverity.Info, true), Location.None));
            }
        });
    }

    public static string FormatClassFromMethods(string @namespace, string pascalFileName, IEnumerable<MethodDefinition> methods, string fileName, PythonFunctionDefinition[] functions, ImmutableArray<byte> hash)
    {
        var paramGenericArgs = methods
            .Select(m => m.ParameterGenericArgs)
            .Where(l => l is not null && l.Any());

        var functionNames = functions.Select(f => (Attr: f.Name, Field: $"__func_{f.Name}")).ToImmutableArray();

        return $$"""
            // <auto-generated/>
            #nullable enable
            using CSnakes.Runtime;
            using CSnakes.Runtime.Python;

            using System;
            using System.Collections.Generic;
            using System.Diagnostics;
            using System.Reflection.Metadata;

            using Microsoft.Extensions.Logging;

            [assembly: MetadataUpdateHandler(typeof({{@namespace}}.{{pascalFileName}}Extensions))]

            namespace {{@namespace}};
            public static class {{pascalFileName}}Extensions
            {
                private static I{{pascalFileName}}? instance;

                private static ReadOnlySpan<byte> HotReloadHash => "{{HexString(hash.AsSpan())}}"u8;

                public static I{{pascalFileName}} {{pascalFileName}}(this IPythonEnvironment env)
                {
                    if (instance is null)
                    {
                        instance = new {{pascalFileName}}Internal(env.Logger);
                    }
                    Debug.Assert(!env.IsDisposed());
                    return instance;
                }

                public static void UpdateApplication(Type[]? updatedTypes) {
                    instance?.ReloadModule();
                }

                private class {{pascalFileName}}Internal : I{{pascalFileName}}
                {
                    private PyObject module;

                    private readonly ILogger<IPythonEnvironment> logger;
                    {{string.Join(Environment.NewLine, functionNames.Select(f => $"private PyObject {f.Field};")) }}

                    internal {{pascalFileName}}Internal(ILogger<IPythonEnvironment> logger)
                    {
                        this.logger = logger;
                        using (GIL.Acquire())
                        {
                            logger.LogDebug("Importing module {ModuleName}", "{{fileName}}");
                            module = Import.ImportModule("{{fileName}}");
                            {{ string.Join(Environment.NewLine, functionNames.Select(f => $"this.{f.Field} = module.GetAttr(\"{f.Attr}\");")) }}
                        }
                    }

                    void IReloadableModuleImport.ReloadModule() {
                        logger.LogDebug("Reloading module {ModuleName}", "{{fileName}}");
                        using (GIL.Acquire())
                        {
                            Import.ReloadModule(ref module);
                            // Dispose old functions
                            {{string.Join(Environment.NewLine, functionNames.Select(f => $"this.{f.Field}.Dispose();"))}}
                            {{string.Join(Environment.NewLine, functionNames.Select(f => $"this.{f.Field} = module.GetAttr(\"{f.Attr}\");"))}}
                        }
                    }

                    public void Dispose()
                    {
                        logger.LogDebug("Disposing module {ModuleName}", "{{fileName}}");
                        {{ string.Join(Environment.NewLine, functionNames.Select(f => $"this.{f.Field}.Dispose();")) }}
                        module.Dispose();
                    }

                    {{methods.Select(m => m.Syntax).Compile()}}
                }
            }
            public interface I{{pascalFileName}} : IReloadableModuleImport
            {
                {{string.Join(Environment.NewLine, methods.Select(m => m.Syntax)
                                                          .Select(m => m.Identifier.Text == "ReloadModule"
                                                                       // This prevents the warning:
                                                                       // > warning CS0108: 'IFooBar.ReloadModule()' hides inherited member 'IReloadableModuleImport.ReloadModule()'. Use the new keyword if hiding was intended.
                                                                       // because `IReloadableModuleImport` already has a `ReloadModule` method.
                                                                       ? m.AddModifiers(SyntaxFactory.Token(SyntaxKind.NewKeyword))
                                                                       : m)
                                                          .Select(m => $"{m.WithBody(null).NormalizeWhitespace()};"))}}
            }
            """;
    }

    private static string HexString(ReadOnlySpan<byte> bytes)
    {
        const string hexChars = "0123456789abcdef";

        var chars = new char[bytes.Length * 2];
        var i = 0;
        foreach (var b in bytes)
        {
            chars[i++] = hexChars[b >> 4];
            chars[i++] = hexChars[b & 0xF];
        }

        return new string(chars);
    }
}
