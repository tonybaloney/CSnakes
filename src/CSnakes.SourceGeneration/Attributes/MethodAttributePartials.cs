using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CSnakes.SourceGeneration.Attributes;
internal class MethodAttributePartials
{
    internal class PythonMethod(string Namespace, string ClassName, string MethodName, string ReturnType, SyntaxTokenList ClassModifiers, SyntaxTokenList MethodModifiers, ParameterListSyntax ParameterList, string PythonName)
    {
        public string GeneratedFileName => $"{ClassName}_{MethodName}.g.cs";

        internal string SourceText
        {
            get
            {
                List<string> argCasts = [];
                string callArgs = string.Join(", ", ParameterList.Parameters.Select(p => $"__python_arg{p.SpanStart}"));
                foreach (var parameter in ParameterList.Parameters)
                {
                    var type = parameter.Type?.ToString();
                    argCasts.Add($"using var __python_arg{parameter.SpanStart} = PyObject.From({parameter.Identifier});");
                }

                return $$"""
                // <auto-generated/>
                using CSnakes.Runtime;
                using CSnakes.Runtime.Python;

                namespace {{Namespace}};
                {{ClassModifiers}} partial class {{ClassName}}
                {
                    {{MethodModifiers}} {{ReturnType}} {{MethodName}}{{ParameterList}}
                    {
                        using (GIL.Acquire()) {
                            {{string.Join(Environment.NewLine, argCasts)}}
                            return Self.GetAttr("{{PythonName}}").Call({{callArgs}}).As<{{ReturnType}}>();
                        }
                    }
                }
                """;
            }
        }
    }

    internal static bool CouldBeMethod(SyntaxNode syntaxNode, CancellationToken _)
    {
        // Debug
        //  System.Diagnostics.Debugger.Launch();
        return syntaxNode is MethodDeclarationSyntax methodDeclaration &&
            methodDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    internal static PythonMethod GetMethodInfo(GeneratorAttributeSyntaxContext context, CancellationToken _)
    {
        var containingClass = context.TargetSymbol.ContainingType;
        if (context.TargetNode is null || containingClass is null)
        {
            throw new InvalidOperationException("Expected a method declaration syntax node and a containing class.");
        }
        if (context.TargetNode is not MethodDeclarationSyntax _)
        {
            throw new InvalidOperationException("Expected a method declaration syntax node.");
        }

        // TODO: Find a way of getting this attribute class?
        string PythonName = context.Attributes[0].ConstructorArguments[0].Value.ToString();

        // TODO: Find if the parent class doesn't have the Self attribute and add it.

        MethodDeclarationSyntax methodDeclaration = context.TargetNode as MethodDeclarationSyntax
            ?? throw new InvalidOperationException("Expected a method declaration syntax node.");
        var returnType = methodDeclaration!.ReturnType.ToString();

        return new PythonMethod(
            // Note: this is a simplified example. You will also need to handle the case where the type is in a global namespace, nested, etc.
            Namespace: containingClass.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)),
            ClassName: containingClass.Name,
            // TODO : more sophisticated handling of the class modifiers
            ClassModifiers: containingClass.DeclaredAccessibility == Accessibility.Public ? SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)) : SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.InternalKeyword)),
            MethodName: context.TargetSymbol.Name,
            MethodModifiers: methodDeclaration!.Modifiers,
            ParameterList: methodDeclaration.ParameterList,
            ReturnType: returnType,
            PythonName: PythonName
            );
    }
}
