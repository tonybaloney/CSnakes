using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using CSnakes.Parser;
using CSnakes.Parser.Types;
using CSnakes.Reflection;
using System.Diagnostics.CodeAnalysis;

namespace CSnakes;

[Generator(LanguageNames.CSharp)]
public class PythonStaticGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // System.Diagnostics.Debugger.Launch();
        var pythonFilesPipeline = context.AdditionalTextsProvider
            .Where(static text => Path.GetExtension(text.Path) == ".py")
            .Collect();

        context.RegisterSourceOutput(pythonFilesPipeline, static (sourceContext, inputFiles) =>
        {
            foreach (var file in inputFiles)
            {
                string filePath = file.Path;
                var fileName = Path.GetFileNameWithoutExtension(filePath);
                // Read the file
                var code = file.GetText(sourceContext.CancellationToken);
                if (code is null) continue;

                // Convert snakecase to pascal case
                var pascalFileName = GetPascalFileName(fileName);

                Action<GeneratorError> errorReporter = error =>
                {
                    Location errorLocation = Location.Create(filePath, TextSpan.FromBounds(0, 1), new LinePositionSpan(new LinePosition(error.StartLine, error.StartColumn), new LinePosition(error.EndLine, error.EndColumn)));
                    sourceContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("PSG004", "PythonStaticGenerator", error.Message, "PythonStaticGenerator", DiagnosticSeverity.Error, true), errorLocation));
                };

                if (TryGenerateCode(errorReporter, pascalFileName, fileName, code, out string? source))
                {
                    sourceContext.AddSource($"{pascalFileName}.py.cs", source);
                    sourceContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("PSG002", "PythonStaticGenerator", $"Generated {pascalFileName}.py.cs", "PythonStaticGenerator", DiagnosticSeverity.Info, true), Location.None));
                }
            }
        });
    }

    public static string GetPascalFileName(string fileName) =>
        string.Join("", fileName.Split('_').Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1)));

    public static bool TryGenerateCode(Action<GeneratorError> errorReporter, string pascalFileName, string fileName, SourceText code, [NotNullWhen(true)] out string? source)
    {
        // Parse the Python file
        var result = PythonParser.TryParseFunctionDefinitions(code, out PythonFunctionDefinition[] functions, out GeneratorError[]? errors);

        foreach (var error in errors)
        {
            // Update text span
            errorReporter(error);
        }

        if (result)
        {
            // Add environment path
            var @namespace = "CSnakes.Runtime";

            IEnumerable<MethodDefinition> methods = ModuleReflection.MethodsFromFunctionDefinitions(functions, fileName);
            source = FormatClassFromMethods(@namespace, pascalFileName, methods, fileName, functions);
            return true;
        }

        source = null;
        return false;
    }

    public static string FormatClassFromMethods(string @namespace, string pascalFileName, IEnumerable<MethodDefinition> methods, string fileName, PythonFunctionDefinition[] functions)
    {
        var paramGenericArgs = methods
            .Select(m => m.ParameterGenericArgs)
            .Where(l => l is not null && l.Any());

        return $$"""
            // <auto-generated/>
            #nullable enable
            using CSnakes.Runtime;
            using CSnakes.Runtime.Python;

            using System;
            using System.Collections.Generic;
            using System.Diagnostics;

            using Microsoft.Extensions.Logging;

            namespace {{@namespace}};
            public static class {{pascalFileName}}Extensions
            {
                private static I{{pascalFileName}}? instance;

                public static I{{pascalFileName}} {{pascalFileName}}(this IPythonEnvironment env)
                {
                    if (instance is null)
                    {
                        instance = new {{pascalFileName}}Internal(env.Logger);
                    }
                    Debug.Assert(!env.IsDisposed());
                    return instance;
                }

                private class {{pascalFileName}}Internal : I{{pascalFileName}}
                {
                    private readonly PyObject module;

                    private readonly ILogger<IPythonEnvironment> logger;
                    private readonly IDictionary<string, PyObject> functions;

                    internal {{pascalFileName}}Internal(ILogger<IPythonEnvironment> logger)
                    {
                        this.logger = logger;
                        using (GIL.Acquire())
                        {
                            logger.LogDebug("Importing module {ModuleName}", "{{fileName}}");
                            module = Import.ImportModule("{{fileName}}");
                            functions = new Dictionary<string, PyObject>();
                            {{string.Join(Environment.NewLine, functions.Select(f => $"functions[\"{f.Name}\"] = module.GetAttr(\"{f.Name}\");"))}}
                        }
                    }

                    public void Dispose()
                    {
                        logger.LogDebug("Disposing module {ModuleName}", "{{fileName}}");
                        foreach (var function in functions)
                        {
                            function.Value.Dispose();
                        }
                        module.Dispose();
                    }

                    {{methods.Select(m => m.Syntax).Compile()}}
                }
            }
            public interface I{{pascalFileName}}
            {
                {{string.Join(Environment.NewLine, methods.Select(m => m.Syntax).Select(m => $"{m.ReturnType.NormalizeWhitespace()} {m.Identifier.Text}{m.ParameterList.NormalizeWhitespace()};"))}}
            }
            """;
    }
}
