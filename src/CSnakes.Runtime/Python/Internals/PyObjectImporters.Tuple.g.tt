<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#
    const string vars = "abcdefghijklmnopqrstuvwxyz";

    var impls =
        from a in Enumerable.Range(2, 12)
        select Enumerable.Range(1, a).Select(n => n.ToString(CultureInfo.InvariantCulture)).ToArray() into ns
        select new
        {
            Types = from n in ns select $"T{n}",
            Importers = from n in ns select $"TImporter{n}",
            Vars = ns.Select((_, i) => vars[i]).ToArray(),
        }
        into e
        select new
        {
            Ts = string.Join(", ", e.Types),
            e.Importers,
            Constraints = e.Types.Zip(e.Importers, (t, c) => new { Type = t, Converter = c }),
            Vars = e.Vars.Select((v, i) => new { Name = v, Index = i.ToString(CultureInfo.InvariantCulture) }),
        };
#>
// <auto-generated/>
//
// To re-generate this file, run the following command, replacing PROJECT with
// the C# project file name to which it belongs:
//
//     dotnet build -t:TransformTextTemplates PROJECT
//

#nullable enable // required for auto-generated sources (see below why)

// > Older code generation strategies may not be nullable aware. Setting the
// > project-level nullable context to "enable" could result in many
// > warnings that a user is unable to fix. To support this scenario any syntax
// > tree that is determined to be generated will have its nullable state
// > implicitly set to "disable", regardless of the overall project state.
//
// Source: https://github.com/dotnet/roslyn/blob/70e158ba6c2c99bd3c3fc0754af0dbf82a6d353d/docs/features/nullable-reference-types.md#generated-code

namespace CSnakes.Runtime.Python.Internals;
partial class PyObjectImporters
{<#
    foreach (var e in impls)
    { #>

    public sealed class Tuple<<#= e.Ts #>, <#= string.Join(", ", e.Importers) #>> :
        IPyObjectImporter<(<#= e.Ts #>)>
<#
        foreach (var c in e.Constraints)
        { #>
        where <#= c.Converter #> : IPyObjectImporter<<#= c.Type #>>
<#      } #>
    {
        public static (<#= e.Ts #>)
            UnsafeImport(PyObject obj)
        {
            CheckTuple(obj);
<#
        foreach (var v in e.Vars)
        { #>
            using var <#= v.Name #> = GetTupleItem(obj, <#= v.Index #>);
<#      } #>
            return (<#= string.Join(", ", e.Importers.Zip(e.Vars, (c, v) => $"{c}.UnsafeImport({v.Name})")) #>);
        }
    }
<#  } #>
}
